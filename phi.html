<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>œÜ = 1.682... ‚âà 137.5¬∞</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #fff;
      font-family: 'Segoe UI', monospace;
      min-height: 100vh;
      overflow: hidden;
    }

    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    .controls {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px 40px;
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(15px);
      z-index: 100;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 15px;
      min-width: 200px;
    }

    .control-label {
      color: #aaa;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 80px;
    }

    input[type="range"] {
      width: 180px;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
      transition: all 0.3s ease;
    }

    input[type="range"]:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      border: 3px solid #000;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
      transition: all 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.3);
      background: #ffcc00;
    }

    .warning {
      color: #ff9900;
      font-size: 0.7rem;
      margin-top: 5px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .warning.show {
      opacity: 1;
    }

    .value-display {
      color: #fff;
      font-size: 1.1rem;
      min-width: 70px;
      font-weight: 300;
      font-variant-numeric: tabular-nums;
      text-align: right;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .phi-display {
      position: fixed;
      top: 30px;
      right: 30px;
      font-size: 2.5rem;
      color: rgba(255, 255, 255, 0.2);
      font-weight: 300;
      letter-spacing: 2px;
      font-family: 'Times New Roman', serif;
      text-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
    }

    .top-controls {
      position: fixed;
      top: 30px;
      left: 30px;
      display: flex;
      gap: 15px;
      z-index: 100;
    }

    .control-btn {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 50%;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      font-size: 1.3rem;
      font-weight: 300;
      backdrop-filter: blur(5px);
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: scale(1.15);
      border-color: rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
    }

    .control-btn:active {
      transform: scale(0.95);
    }

    .gradient-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 20% 30%, rgba(255, 100, 0, 0.05) 0%, transparent 40%),
        radial-gradient(circle at 80% 70%, rgba(0, 200, 255, 0.03) 0%, transparent 40%),
        radial-gradient(circle at 40% 80%, rgba(255, 0, 150, 0.04) 0%, transparent 40%);
      pointer-events: none;
      z-index: -1;
    }

    .title {
      position: fixed;
      top: 35px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.4);
      font-weight: 300;
      letter-spacing: 3px;
      text-transform: uppercase;
      z-index: 100;
    }

    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        gap: 20px;
        bottom: 20px;
        padding: 15px;
        width: 90%;
        border-radius: 12px;
      }

      .control-group {
        min-width: auto;
        width: 100%;
      }

      input[type="range"] {
        width: 100%;
      }

      .phi-display {
        font-size: 2rem;
        top: 20px;
        right: 20px;
      }

      .top-controls {
        top: 20px;
        left: 20px;
        gap: 10px;
      }

      .control-btn {
        width: 45px;
        height: 45px;
        font-size: 1.2rem;
      }

      .title {
        top: 25px;
        font-size: 1rem;
        letter-spacing: 2px;
      }
    }

    @media (max-width: 480px) {
      .phi-display {
        font-size: 1.8rem;
        top: 15px;
        right: 15px;
      }

      .top-controls {
        top: 15px;
        left: 15px;
      }

      .control-btn {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
      }

      .title {
        top: 20px;
        font-size: 0.9rem;
        letter-spacing: 1px;
      }

      .controls {
        bottom: 15px;
        padding: 12px;
      }
    }

    /* Animaci√≥n sutil para el phi */
    @keyframes pulse {

      0%,
      100% {
        opacity: 0.2;
      }

      50% {
        opacity: 0.4;
      }
    }

    .phi-display {
      animation: pulse 8s ease-in-out infinite;
    }
  </style>
</head>

<body>
  <div class="gradient-bg"></div>

  <div class="container">
    <canvas id="sunflowerCanvas"></canvas>
  </div>

  <div class="phi-display">œÜ</div>
  <div class="title">œÜ = 1.682... ‚âà 137.5¬∞</div>

  <div class="top-controls">
    <button class="control-btn" id="colorToggle" title="Alternar color">C</button>
    <button class="control-btn" id="resetBtn" title="Configuraci√≥n por defecto">‚Ü∫</button>
  </div>

  <div class="controls">
    <div class="control-group">
      <div class="control-label">Ratio œÜ</div>
      <input type="range" id="angleSlider" min="120" max="155" step="0.1" value="137.5">
      <div class="value-display" id="angleValue">137.5¬∞</div>
    </div>

    <div class="control-group">
      <div class="control-label"></div>
      <div style="display: flex; flex-direction: column; width: 180px;">
        <input type="range" id="seedsSlider" min="1" max="30000" step="1" value="1500">
        <div class="warning" id="performanceWarning">‚ö† Alto consumo GPU</div>
      </div>
      <div class="value-display" id="seedsValue">1500</div>
    </div>

    <div class="control-group">
      <div class="control-label">Tama√±o</div>
      <input type="range" id="sizeSlider" min="0.2" max="5" step="0.1" value="2">
      <div class="value-display" id="sizeValue">2.0</div>
    </div>
  </div>

  <script>
    // ======================
    // CONFIGURACI√ìN Y CONSTANTES
    // ======================
    const PHI = (1 + Math.sqrt(5)) / 2;
    const GOLDEN_ANGLE = 360 / (PHI * PHI); // ‚âà 137.5¬∞

    // Configuraci√≥n por defecto - ZOOM M√ÅXIMO
    const DEFAULT_CONFIG = {
      angle: GOLDEN_ANGLE,   // 137.5¬∞ exacto
      seeds: 5000,          // Alta densidad
      size: 2.5,            // Tama√±o minimalista
      scale: 10,           // ZOOM M√ÅXIMO (m√°s cercano posible)
      offsetX: 0,
      offsetY: 0,
      colorMode: true
    };

    // L√≠mites
    const MIN_SCALE = 0.5;   // M√≠nimo zoom (m√°s cerca)
    const MAX_SCALE = 10;     // M√°ximo zoom (m√°s lejos)
    const PERFORMANCE_THRESHOLD = 5000; // Advertencia de GPU

    // ======================
    // ELEMENTOS DEL DOM
    // ======================
    const canvas = document.getElementById('sunflowerCanvas');
    const ctx = canvas.getContext('2d');
    const angleSlider = document.getElementById('angleSlider');
    const seedsSlider = document.getElementById('seedsSlider');
    const sizeSlider = document.getElementById('sizeSlider');
    const angleValue = document.getElementById('angleValue');
    const seedsValue = document.getElementById('seedsValue');
    const sizeValue = document.getElementById('sizeValue');
    const colorToggle = document.getElementById('colorToggle');
    const resetBtn = document.getElementById('resetBtn');
    const performanceWarning = document.getElementById('performanceWarning');

    // ======================
    // ESTADO DE LA APLICACI√ìN
    // ======================
    let state = {
      angle: parseFloat(angleSlider.value),
      seedCount: parseInt(seedsSlider.value),
      sizeMultiplier: parseFloat(sizeSlider.value),
      colorMode: true,
      scale: 7,
      offsetX: 0,
      offsetY: 0,
      isDragging: false,
      lastX: 0,
      lastY: 0,
      animationId: null,
      isDefaultApplied: false
    };

    // ======================
    // FUNCIONES DE DEBUGGING
    // ======================
    function logState(action = 'Estado actual') {
      console.groupCollapsed(`%cüîß ${action}`, 'color: #4CAF50; font-weight: bold;');
      console.log(`%c√Ångulo: ${state.angle.toFixed(1)}¬∞`, 'color: #2196F3');
      console.log(`%cSemillas: ${state.seedCount}`, 'color: #E91E63');
      console.log(`%cTama√±o: ${state.sizeMultiplier.toFixed(1)}`, 'color: #FF9800');
      console.log(`%cZoom: ${state.scale.toFixed(3)}`, 'color: #9C27B0');
      console.log(`%cColor: ${state.colorMode ? 'üåà Color' : '‚ö´ Blanco/Transparente'}`, 'color: #00BCD4');
      console.log(`%cOffset: X=${state.offsetX.toFixed(0)}, Y=${state.offsetY.toFixed(0)}`, 'color: #795548');
      console.groupEnd();
    }

    function logDefaultConfig() {
      console.group('%c‚öôÔ∏è  Configuraci√≥n por defecto', 'color: #FF9800; font-weight: bold;');
      console.table(DEFAULT_CONFIG);
      console.groupEnd();
    }

    function logPerformanceWarning() {
      if (state.seedCount >= PERFORMANCE_THRESHOLD) {
        console.warn(`%c‚ö†Ô∏è  ALTO CONSUMO GPU: ${state.seedCount} semillas`,
          'color: #FF5722; font-weight: bold; font-size: 14px;');
        console.log('%cConsidera reducir a menos de 5000 semillas para mejor rendimiento.',
          'color: #FF9800');
      }
    }

    // ======================
    // FUNCIONES DE COLOR MEJORADAS
    // ======================
    function getBWGradientColor(i, radius, maxVisibleRadius) {
      // RADIAL: Blanco en el centro ‚Üí Transparente en los bordes

      // 1. Factor radial basado en distancia desde el centro
      // 0 en el centro, 1 en el borde
      const radialFactor = Math.min(1, radius / (maxVisibleRadius * 0.9));

      // 2. Suavizar con curva exponencial para mejor transici√≥n
      const smoothFactor = 1 - Math.pow(radialFactor, 1.5);

      // 3. A√±adir variaci√≥n espiral suave basada en posici√≥n angular
      const theta = i * (state.angle * Math.PI / 180);
      const spiralVariation = 0.95 + 0.1 * Math.sin(theta * 3);

      // 4. Calcular opacidad final
      // Centro: ~0.9, Bordes: ~0.1
      let opacity = 0.15 + smoothFactor * 0.75;
      opacity *= spiralVariation;

      // 5. Asegurar l√≠mites
      opacity = Math.max(0.05, Math.min(0.95, opacity));

      // 6. Color blanco con opacidad variable
      return `rgba(255, 255, 255, ${opacity})`;
    }

    function getFullColor(i, radius, theta, maxVisibleRadius) {
      if (!state.colorMode) {
        return getBWGradientColor(i, radius, maxVisibleRadius);
      }

      // Modo color - paleta completa
      const hue = (theta * 180 / Math.PI * 2 + i * 0.5) % 360;
      const saturation = 75 + Math.sin(i * 0.02) * 15;
      const maxRadius = Math.sqrt(state.seedCount) * 2;
      const lightness = 40 + (1 - radius / maxRadius) * 35;

      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    // ======================
    // FUNCIONES DE INICIALIZACI√ìN
    // ======================
    function init() {
      console.log('%cüåª Girasol de Phi inicializado', 'color: #FFCC00; font-size: 16px; font-weight: bold;');
      console.log('%c‚ö´ Modo Blanco/Transparente: Gradiente radial mejorado', 'color: #FFFFFF; background: #000; padding: 2px 5px;');
      logDefaultConfig();

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      setupEventListeners();
      updatePerformanceWarning();
      logState('Estado inicial');

      animate();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }

    function setupEventListeners() {
      // Sliders
      angleSlider.addEventListener('input', updateAngle);
      seedsSlider.addEventListener('input', updateSeeds);
      sizeSlider.addEventListener('input', updateSize);

      // Botones
      colorToggle.addEventListener('click', toggleColorMode);
      resetBtn.addEventListener('click', resetToDefault);

      // Mouse
      canvas.addEventListener('mousedown', startDrag);
      canvas.addEventListener('mousemove', drag);
      canvas.addEventListener('mouseup', endDrag);
      canvas.addEventListener('mouseleave', endDrag);
      canvas.addEventListener('wheel', handleZoom);

      // Touch
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', endDrag);
    }

    // ======================
    // FUNCIONES DE ACTUALIZACI√ìN
    // ======================
    function updateAngle() {
      state.angle = parseFloat(angleSlider.value);
      angleValue.textContent = `${state.angle.toFixed(1)}¬∞`;
      console.log(`%c‚Üª √Ångulo actualizado: ${state.angle.toFixed(1)}¬∞`, 'color: #2196F3');
      draw();
    }

    function updateSeeds() {
      state.seedCount = parseInt(seedsSlider.value);
      seedsValue.textContent = state.seedCount;
      updatePerformanceWarning();
      logPerformanceWarning();
      console.log(`%cüå± Semillas actualizadas: ${state.seedCount}`, 'color: #4CAF50');
      draw();
    }

    function updateSize() {
      state.sizeMultiplier = parseFloat(sizeSlider.value);
      sizeValue.textContent = state.sizeMultiplier.toFixed(1);
      console.log(`%c‚öôÔ∏è  Tama√±o actualizado: ${state.sizeMultiplier.toFixed(1)}`, 'color: #FF9800');
      draw();
    }

    function updatePerformanceWarning() {
      if (state.seedCount >= PERFORMANCE_THRESHOLD) {
        performanceWarning.classList.add('show');
      } else {
        performanceWarning.classList.remove('show');
      }
    }

    function toggleColorMode() {
      state.colorMode = !state.colorMode;
      colorToggle.textContent = state.colorMode ? 'C' : 'B/T';
      console.log(`%cüé® Modo ${state.colorMode ? 'üåà Color' : '‚ö´ Blanco/Transparente'}`,
        `color: ${state.colorMode ? '#E91E63' : '#FFFFFF'}; font-weight: bold;`);
      draw();
    }

    // ======================
    // FUNCI√ìN DE RESET MEJORADA
    // ======================
    function resetToDefault() {
      console.group('%cüîÑ Aplicando configuraci√≥n por defecto', 'color: #00BCD4; font-weight: bold;');

      // Aplicar TODOS los valores por defecto
      state.angle = DEFAULT_CONFIG.angle;
      state.seedCount = DEFAULT_CONFIG.seeds;
      state.sizeMultiplier = DEFAULT_CONFIG.size;
      state.scale = DEFAULT_CONFIG.scale; // ZOOM M√ÅXIMO
      state.offsetX = DEFAULT_CONFIG.offsetX;
      state.offsetY = DEFAULT_CONFIG.offsetY;
      state.colorMode = DEFAULT_CONFIG.colorMode;
      state.isDefaultApplied = true;

      // Actualizar controles UI
      angleSlider.value = state.angle;
      seedsSlider.value = state.seedCount;
      sizeSlider.value = state.sizeMultiplier;

      // Actualizar displays
      angleValue.textContent = `${state.angle.toFixed(1)}¬∞`;
      seedsValue.textContent = state.seedCount;
      sizeValue.textContent = state.sizeMultiplier.toFixed(1);
      colorToggle.textContent = state.colorMode ? 'C' : 'B/T';

      // Actualizar advertencia de rendimiento
      updatePerformanceWarning();

      console.log('‚úÖ Configuraci√≥n aplicada:');
      console.table({
        '√Ångulo œÜ': `${state.angle.toFixed(1)}¬∞`,
        'Semillas': state.seedCount,
        'Tama√±o': state.sizeMultiplier,
        'Zoom': `M√ÅXIMO (${state.scale})`,
        'Color': state.colorMode ? 'Activado' : 'Desactivado'
      });
      console.groupEnd();

      // Redibujar
      draw();

      // Efecto visual de confirmaci√≥n
      canvas.style.transition = 'transform 0.5s ease';
      canvas.style.transform = 'scale(0.95)';
      setTimeout(() => {
        canvas.style.transform = 'scale(1)';
        setTimeout(() => {
          canvas.style.transition = '';
        }, 500);
      }, 100);
    }

    // ======================
    // FUNCIONES DE INTERACCI√ìN
    // ======================
    function startDrag(e) {
      state.isDragging = true;
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      state.lastX = clientX;
      state.lastY = clientY;
      canvas.style.cursor = 'grabbing';
    }

    function drag(e) {
      if (!state.isDragging) return;

      e.preventDefault();

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      const deltaX = clientX - state.lastX;
      const deltaY = clientY - state.lastY;

      state.offsetX += deltaX;
      state.offsetY += deltaY;

      state.lastX = clientX;
      state.lastY = clientY;

      draw();
    }

    function endDrag() {
      state.isDragging = false;
      canvas.style.cursor = 'grab';
    }

    function handleZoom(e) {
      e.preventDefault();

      // Si estamos en modo default y el usuario hace zoom, marcamos que ya no es default
      if (state.isDefaultApplied) {
        state.isDefaultApplied = false;
        console.log('%cüîç Modo default desactivado (usuario hizo zoom)', 'color: #FF9800');
      }

      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      state.scale *= delta;
      state.scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale));

      console.log(`%cüîç Zoom: ${state.scale.toFixed(3)}`, 'color: #9C27B0');
      draw();
    }

    function handleTouchStart(e) {
      e.preventDefault();
      if (e.touches.length === 1) {
        startDrag(e);
      } else if (e.touches.length === 2) {
        handlePinchStart(e);
      }
    }

    function handleTouchMove(e) {
      e.preventDefault();
      if (e.touches.length === 1) {
        drag(e);
      } else if (e.touches.length === 2) {
        handlePinch(e);
      }
    }

    let pinchStartDistance = 0;
    let pinchStartScale = 1;

    function handlePinchStart(e) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
      pinchStartScale = state.scale;
    }

    function handlePinch(e) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const currentDistance = Math.sqrt(dx * dx + dy * dy);

      if (pinchStartDistance > 0) {
        state.scale = pinchStartScale * (currentDistance / pinchStartDistance);
        state.scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale));
        draw();
      }
    }

    // ======================
    // FUNCIONES DE DIBUJO MEJORADAS
    // ======================
    function draw() {
      const centerX = canvas.width / 2 + state.offsetX;
      const centerY = canvas.height / 2 + state.offsetY;
      const maxRadius = Math.sqrt(state.seedCount) * 2 * state.scale;

      // Fondo negro
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // √Årea visible
      const visibleRadius = Math.min(maxRadius, Math.max(canvas.width, canvas.height) * 0.8);

      // Para debugging del gradiente
      if (!state.colorMode && state.seedCount < 100) {
        console.group('%cüéØ Debug: Gradiente Blanco/Transparente', 'color: #FFFFFF; font-weight: bold;');
        console.log(`%cRadio visible: ${visibleRadius.toFixed(1)}px`, 'color: #9C27B0');
        console.log(`%cRadio m√°ximo: ${maxRadius.toFixed(1)}px`, 'color: #9C27B0');
        console.groupEnd();
      }

      // Dibujar en batches para rendimiento
      const batchSize = Math.min(500, Math.max(100, Math.floor(state.seedCount / 10)));

      for (let batchStart = 0; batchStart < state.seedCount; batchStart += batchSize) {
        const batchEnd = Math.min(batchStart + batchSize, state.seedCount);

        for (let i = batchStart; i < batchEnd; i++) {
          const radius = Math.sqrt(i) * 2 * state.scale;
          if (radius > visibleRadius) continue;

          const theta = i * (state.angle * Math.PI / 180);
          const x = centerX + radius * Math.cos(theta);
          const y = centerY + radius * Math.sin(theta);

          if (x < -50 || x > canvas.width + 50 || y < -50 || y > canvas.height + 50) {
            continue;
          }

          const baseSize = Math.max(0.1, (1 - radius / visibleRadius) * 4);
          const size = baseSize * state.sizeMultiplier;

          // Usar funci√≥n mejorada de color
          ctx.fillStyle = getFullColor(i, radius, theta, visibleRadius);

          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();

          // Destello sutil solo en modo color
          if (state.colorMode && size > 0.8) {
            ctx.beginPath();
            ctx.arc(x - size * 0.25, y - size * 0.25, size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();
          }
        }
      }

      // Indicador de centro cuando hay zoom m√°ximo
      if (state.scale <= MIN_SCALE * 1.5) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fill();
      }

      // DEBUG: Mostrar informaci√≥n del gradiente en pocas semillas
      if (!state.colorMode && state.seedCount < 50) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = '12px monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`Gradiente: Blanco(centro) ‚Üí Transparente(bordes)`, 10, 20);
        ctx.fillText(`Radio visible: ${Math.round(visibleRadius)}px`, 10, 40);
      }
    }

    function animate() {
      draw();
      state.animationId = requestAnimationFrame(animate);
    }

    // ======================
    // INICIALIZAR APLICACI√ìN
    // ======================
    init();
  </script>
</body>

</html>
